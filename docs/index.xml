<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Documentation on CIRCT</title><link>https://circt.llvm.org/docs/</link><description>Recent content in Code Documentation on CIRCT</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://circt.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://circt.llvm.org/docs/CalyxPasses/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/CalyxPasses/</guid><description>-calyx-compile-control: Generates latency-insensitive finite state machines to realize control. This pass performs a bottom-up traversal of the control program and does the following:
For each control statement such as &amp;ldquo;calyx.seq&amp;rdquo;, create a new GroupOp to contain all the structure to realize the schedule. Implement the schedule by setting the constituent groups&amp;rsquo; GoOp and DoneOp. Replace the control statement in the control program with the corresponding compilation group. -calyx-go-insertion: Insert go signals into the guards of a group&amp;rsquo;s non-hole assignments This pass inserts the operation &amp;ldquo;calyx.</description></item><item><title>`comb` Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleComb/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleComb/</guid><description>This document describes various design points of the Comb dialect, a common dialect that is typically used in conjunction with the hw and sv dialects. Please see the hw Dialect Rationale for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
comb Dialect Rationale Introduction to the comb Dialect Type System for comb Dialect Zero-bit integer width is not supported Comb Operations Fully associative operations are variadic Operators carry signs instead of types No implicit extensions of operands No &amp;ldquo;Complement&amp;rdquo;, &amp;ldquo;Negate&amp;rdquo;, &amp;ldquo;ZExt&amp;rdquo;, &amp;ldquo;SExt&amp;rdquo;, Operators No multibit mux operations Endianness: operand ordering and internal representation Bitcasts Cost Model Introduction to the comb Dialect The comb dialect provides a collection of operations that define a mid-level compiler IR for combinational logic.</description></item><item><title>CIRCT Charter</title><link>https://circt.llvm.org/docs/Charter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Charter/</guid><description>Abstract Recent trends in computer architecture have resulted in two core problems. Firstly, how do we design complex, heterogenous systems-on-chip mixing general purpose and specialized components? Secondly, how do we program them? We believe that design tools that represent and manipulate a wide variety of abstractions are central to solving these problems. This projects is focused on using LLVM/MLIR to express these abstractions and to build useable open-source flows based on those abstractions to solve the design problems of the next decade.</description></item><item><title>FIRRTL Annotations</title><link>https://circt.llvm.org/docs/FIRRTLAnnotations/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/FIRRTLAnnotations/</guid><description>The Scala FIRRTL Compiler (SFC) provides a mechanism to encode arbitrary metadata and associate it with zero or more &amp;ldquo;things&amp;rdquo; in a FIRRTL circuit. This mechanism is an Annotation and the association is described using one or more Targets. Annotations should be viewed an extension to the FIRRTL IR specification, and can greatly affect the meaning and interpretation of the IR.
Annotations are represented as a dictionary, with a &amp;ldquo;class&amp;rdquo; field which describes which annotation it is, and a &amp;ldquo;target&amp;rdquo; field which represents the IR object it is attached to.</description></item><item><title>FIRRTL Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleFIRRTL/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleFIRRTL/</guid><description>This document describes various design points of the FIRRTL dialect, why it is the way it is, and current status and progress. This follows in the spirit of other MLIR Rationale docs.
Introduction The FIRRTL project is an existing open source compiler infrastructure used by the Chisel framework to lower &amp;ldquo;.fir&amp;rdquo; files to Verilog. It provides a number of useful compiler passes and infrastructure that allows the development of domain specific passes.</description></item><item><title>FSM Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleFSM/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleFSM/</guid><description>This document describes various design points of the FSM dialect, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Finite-state machine (FSM) is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.</description></item><item><title>Getting Started with the CIRCT Project</title><link>https://circt.llvm.org/docs/GettingStarted/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/GettingStarted/</guid><description>Overview Welcome to the CIRCT project!
&amp;ldquo;CIRCT&amp;rdquo; stands for &amp;ldquo;Circuit IR Compilers and Tools&amp;rdquo;. The CIRCT project is an (experimental!) effort looking to apply MLIR and the LLVM development methodology to the domain of hardware design tools.
Take a look at the following diagram, which gives a brief overview of the current dialects and how they interact:
Setting this up These commands can be used to setup CIRCT project:
Install Dependencies of LLVM/MLIR according to the instructions, including cmake and ninja.</description></item><item><title>Handshake Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleHandshake/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleHandshake/</guid><description>Principle Choice of MLIR IR Representation Conventions Resources Operation definitions This document also explains in a high-level manner how different components are organized, the principles behind them and the conventions we followed. The document assume that you have basic understanding of asynchronous digital circuits at the behavioral level abstraction.
Principle Handshake/dataflow IR is describes independent, unsynchronized processes communicating data through First-in First-out (FIFO) communication channels. This can be implemented in many ways, such as using synchronous logic, or with processors.</description></item><item><title>HW Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleHW/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleHW/</guid><description>This document describes various design points of the hw dialect as well as global perspective on the hw, comb, and sv dialects, why they are the way they are, and current status. This follows in the spirit of other MLIR Rationale docs. For more information about the other dialects, please see the Comb Dialect Rationale and SV Dialect Rationale.
HW Dialect Rationale General Introduction Introduction to the hw Dialect hw Type System hw.</description></item><item><title>Passes</title><link>https://circt.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/Passes/</guid><description>This document describes the available CIRCT passes and their contracts.
Conversion Passes -convert-affine-to-staticlogic: Convert Affine dialect to StaticLogic pipelines -convert-hw-to-llhd: Convert HW to LLHD -convert-llhd-to-llvm: Convert LLHD to LLVM -convert-moore-to-core: Convert Moore to Core -create-pipeline: Create StaticLogic pipeline operations -export-split-verilog: Emit the IR to a (System)Verilog directory of files -export-verilog: Emit the IR to a (System)Verilog file -handshake-remove-block-structure: Remove block structure in Handshake IR -lower-calyx-to-hw: Lower Calyx to HW -lower-firrtl-to-hw: Lower FIRRTL to HW -lower-handshake-to-firrtl: Lower Handshake to FIRRTL -lower-handshake-to-hw: Lower Handshake to ESI/HW/Comb/Seq -lower-scf-to-calyx: Lower SCF/Standard to Calyx -lower-std-to-handshake: Lower Standard MLIR into Handshake IR ESI Dialect Passes -lower-esi-ports: Lower ESI input and/or output ports.</description></item><item><title>PyCDE</title><link>https://circt.llvm.org/docs/PyCDE/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PyCDE/</guid><description>PyCDE stands for Python circuit design entry. It is an experimental, opinionated, Python-based fronted for CIRCT&amp;rsquo;s Python bindings. The goal is to make the definition of hardware modules using the bindings simple.
Installation via Pip PyCDE is now being released on PyPI: https://pypi.org/project/pycde/
Installing and Building with Wheels The simplest way to get started using PyCDE is to install it with the pip install command:
$ cd circt $ pip install frontends/PyCDE --use-feature=in-tree-build If you just want to build the wheel, use the pip wheel command:</description></item><item><title>Seq(uential) Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleSeq/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSeq/</guid><description>This document describes various design points of the seq dialect, why it is the way it is, and current status. This follows in the spirit of other MLIR Rationale docs.
Introduction Digital logic is generally split into two categories: combinational and sequential. CIRCT contains a comb dialect to model the basic combinational operations and the (future) seq dialect which is discussed here. The intention of the seq dialect is to provide a set of stateful constructs which can be used to model sequential logic, independent of the output method (e.</description></item><item><title>SV Dialect Rationale</title><link>https://circt.llvm.org/docs/RationaleSV/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleSV/</guid><description>This document describes various design points of the sv dialect, a common dialect that is typically used in conjunction with the hw and comb dialects. Please see the [RationaleHW.md](HW Dialect Rationale) for high level insight on how these work together. This follows in the spirit of other MLIR Rationale docs.
SV Dialect Rationale Introduction to the sv dialect sv Type System Overview of sv dialect operations Statements Declarations Expressions Verbatim op Cost Model Introduction to the sv dialect The sv dialect is one of the dialects that can be mixed into the HW dialect, providing access to a range of syntactic and behavioral constructs in SystemVerilog.</description></item><item><title>The Elastic Silicon Interconnect dialect</title><link>https://circt.llvm.org/docs/RationaleESI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/RationaleESI/</guid><description>Long ago, software function calling conventions were ad-hoc. This led to issues, particularly with register clobbering and stack corruption. This is &amp;ndash; in large part &amp;ndash; the state of FPGA/ASIC design today: wire signaling protocols are often ad-hoc, which also leads to major issues. Though there are efforts to standardize the signaling protocols there are many minor and major variants, both of which lead to confusion which can cause real problems when one is listening to and twiddling the wires manually.</description></item><item><title>Using the Python Bindings</title><link>https://circt.llvm.org/docs/PythonBindings/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/PythonBindings/</guid><description>If you are mainly interested in using CIRCT from Python scripts, you need to compile both LLVM/MLIR and CIRCT with Python bindings enabled. Furthermore, you must use a unified build, where LLVM/MLIR and CIRCT are compiled together in one step.
CIRCT also includes an experimental, opinionated frontend for CIRCT&amp;rsquo;s Python bindings, called PyCDE.
Installing and Building with Wheels CIRCT provides a setup.py script that take care of configuring and building LLVM/MLIR, CIRCT, and CIRCT&amp;rsquo;s Python bindings.</description></item><item><title>Verilog and SystemVerilog Generation</title><link>https://circt.llvm.org/docs/VerilogGeneration/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://circt.llvm.org/docs/VerilogGeneration/</guid><description>Verilog and SystemVerilog are critical components of the hardware design tool ecosystem, but generating syntatically correct Verilog that is acceptable by a wide range of tools is a challenge &amp;ndash; and generating &amp;ldquo;good looking&amp;rdquo; output even more so. This document describes CIRCT&amp;rsquo;s approach and support for generating Verilog and SystemVerilog, some of the features and capabilities provided, and information about the internal layering of the related subsystems.
Why is this hard?</description></item></channel></rss>